/**
 * @copyright Copyright (c) 2023
 * 
 * @author Hugo Fernandez Solis (hugofernandezsolis@gmail.com)
 * @date 12-08-2024
 * 
 * @file InternetAddressTest.cpp
 * 
 * @brief
 */

#include <InternetAddressTest.h>

#include <cstdlib>
#include <ctime>
#include <iomanip>


namespace ncs { // Network Communications System
namespace addr { // Network Communications System Addresses
namespace tests { // Tests


/** PUBLIC METHODS */

/// PUBLIC //////////////////////////////////////     CONSTRUCTORS    //////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// PUBLIC //////////////////////////////////////    CLASS METHODS    //////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// PUBLIC //////////////////////////////////////  SETTERS & GETTERS  //////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// PUBLIC //////////////////////////////////////  OUTPUT FORMATTERS  //////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// PUBLIC //////////////////////////////////////       OPERATORS     //////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// PUBLIC ///////////////////////////////////////  FRIEND FUNCTIONS  //////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// PUBLIC //////////////////////////////////////     DESTRUCTORS     //////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  

/** PROTECTED METHODS **/

/// PROTECTED ///////////////////////////////////     CONSTRUCTORS    //////////////////////////////////////////////////
/**
 * @brief 
 */
void InternetAddressTest::SetUp() {
  defaultFamily_ = get_random_number(0, 1) ? NET_ADDR_FAM_INET : NET_ADDR_FAM_INET6;
  defaultIp_ = defaultFamily_ == NET_ADDR_FAM_INET ? generate_ipv4(true) : generate_ipv6(true);
  defaultPort_ = get_random_number(MIN_VALID_PORT, MAX_VALID_PORT);
  defaultAddr_ = {defaultIp_, defaultPort_};
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// PROTECTED ///////////////////////////////////    CLASS METHODS    //////////////////////////////////////////////////
/**
 * @brief 
 * 
 * @param iValid 
 * 
 * @return
 */
std::string InternetAddressTest::generate_ipv4(const bool& iValid) {
  std::ostringstream ip_stream;
  std::array<int, 4> ipv4_arr;
  for (int& digit : ipv4_arr) {
    digit = get_random_number(0, 255);
  }
  if (iValid) {
    ip_stream << ipv4_arr[0] << '.' << ipv4_arr[1] << '.' << ipv4_arr[2] << '.' << ipv4_arr[3];
  }
  else {
    if (get_random_number(0, 1)) {  // Modify one digit's value
      if (get_random_number(0, 1)) {  // Make one digit bigger than allowed
        ipv4_arr.at(get_random_number(0, ipv4_arr.size() - 1)) = get_random_number(256, 999);
        ip_stream << ipv4_arr[0] << '.' << ipv4_arr[1] << '.' << ipv4_arr[2] << '.' << ipv4_arr[3];
      }
      else {  // Make one digit smaller than allowed
        ipv4_arr.at(get_random_number(0, ipv4_arr.size() - 1)) = get_random_number(-99, -1);
        ip_stream << ipv4_arr[0] << '.' << ipv4_arr[1] << '.' << ipv4_arr[2] << '.' << ipv4_arr[3];
      }
    }
    else {  // Modify number of digits
      if (get_random_number(0, 1)) {  // Add one extra digit
        ip_stream << ipv4_arr[0] << '.' << ipv4_arr[1] << '.' << ipv4_arr[2] << '.' << ipv4_arr[3]
                  << '.' << get_random_number(0, 255);
      }
      else {  // Remove one digit
        ip_stream << ipv4_arr[0] << '.' << ipv4_arr[1] << '.' << ipv4_arr[2];
      }
    }
  }
  return ip_stream.str();
}

/**
 * @brief 
 * 
 * @param iValid 
 * 
 * @return
 */
std::string InternetAddressTest::generate_ipv6(const bool& iValid) {
  std::ostringstream ip_stream;
  std::array<int, 8> ipv6_arr;
  for (int& element : ipv6_arr) {
    element = get_random_number(0, 65535);
  }
  if (iValid) {
    ip_stream << to_hex(ipv6_arr[0]) << ':' << to_hex(ipv6_arr[1]) << ':' << to_hex(ipv6_arr[2]) << ':' << to_hex(ipv6_arr[3]) << ':'
              << to_hex(ipv6_arr[4]) << ':' << to_hex(ipv6_arr[5]) << ':' << to_hex(ipv6_arr[6]) << ':' << to_hex(ipv6_arr[7]);
  }
  else {
    if (get_random_number(0, 1)) {  // Modify one digit's value
      if (get_random_number(0, 1)) {  // Make one digit bigger than allowed
        ipv6_arr.at(get_random_number(0, ipv6_arr.size() - 1)) = get_random_number(0x10000, 0xFFFFF);
        ip_stream << to_hex(ipv6_arr[0]) << ':' << to_hex(ipv6_arr[1]) << ':' << to_hex(ipv6_arr[2]) << ':' << to_hex(ipv6_arr[3]) << ':'
                  << to_hex(ipv6_arr[4]) << ':' << to_hex(ipv6_arr[5]) << ':' << to_hex(ipv6_arr[6]) << ':' << to_hex(ipv6_arr[7]);
      }
      else {  // Make one digit smaller than allowed
        ipv6_arr.at(get_random_number(0, ipv6_arr.size() - 1)) = get_random_number(-99, -1);
        ip_stream << to_hex(ipv6_arr[0]) << ':' << to_hex(ipv6_arr[1]) << ':' << to_hex(ipv6_arr[2]) << ':' << to_hex(ipv6_arr[3]) << ':'
                  << to_hex(ipv6_arr[4]) << ':' << to_hex(ipv6_arr[5]) << ':' << to_hex(ipv6_arr[6]) << ':' << to_hex(ipv6_arr[7]);
      }
    }
    else {  // Modify number of digits
      if (get_random_number(0, 1)) {  // Add one extra digit
        ip_stream << to_hex(ipv6_arr[0]) << ':' << to_hex(ipv6_arr[1]) << ':' << to_hex(ipv6_arr[2]) << ':' << to_hex(ipv6_arr[3]) << ':'
                  << to_hex(ipv6_arr[4]) << ':' << to_hex(ipv6_arr[5]) << ':' << to_hex(ipv6_arr[6]) << ':' << to_hex(ipv6_arr[7])
                  << ':' << get_random_number(0x0000, 0xFFFF);
      }
      else {  // Remove one digit
        ip_stream << to_hex(ipv6_arr[0]) << ':' << to_hex(ipv6_arr[1]) << ':' << to_hex(ipv6_arr[2]) << ':' << to_hex(ipv6_arr[3]) << ':'
                  << to_hex(ipv6_arr[4]) << ':' << to_hex(ipv6_arr[5]) << ':' << to_hex(ipv6_arr[6]);
      }
    }
  }
  return ip_stream.str();
}

/**
 * @brief
 * 
 * @param min 
 * @param max 
 * 
 * @return
 */
int InternetAddressTest::get_random_number(const int& min, const int& max) {
  return min + rand() % (max - min + 1);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// PROTECTED ///////////////////////////////////  SETTERS & GETTERS  //////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// PROTECTED ///////////////////////////////////  OUTPUT FORMATTERS  //////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// PROTECTED ///////////////////////////////////       OPERATORS     //////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// PROTECTED ///////////////////////////////////     DESTRUCTORS     //////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  

/** PRIVATE METHODS **/

/// PRIVATE /////////////////////////////////////     CONSTRUCTORS    //////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// PRIVATE /////////////////////////////////////    CLASS METHODS    //////////////////////////////////////////////////
/**
 * @brief 
 * 
 * @param val 
 * 
 * @return 
 */
std::string InternetAddressTest::to_hex(const int& val) {
  std::stringstream ss;
  ss << std::hex << std::uppercase << val;
  return ss.str();
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// PRIVATE /////////////////////////////////////  SETTERS & GETTERS  //////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// PRIVATE /////////////////////////////////////  OUTPUT FORMATTERS  //////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// PRIVATE /////////////////////////////////////       OPERATORS     //////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// PRIVATE /////////////////////////////////////     DESTRUCTORS     //////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


} // namespace tests
} // namespace addr
} // namespace ncs